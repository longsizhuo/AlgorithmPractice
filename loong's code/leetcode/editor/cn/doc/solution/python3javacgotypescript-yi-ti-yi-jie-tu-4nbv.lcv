**æ–¹æ³•ä¸€ï¼šæ‹“æ‰‘æ’åº + åŠ¨æ€è§„åˆ’**

æˆ‘ä»¬é¦–å…ˆæ ¹æ®ç»™å®šçš„å…ˆä¿®è¯¾ç¨‹å…³ç³»ï¼Œæ„å»ºå‡ºä¸€ä¸ªæœ‰å‘æ— ç¯å›¾ï¼Œå¯¹è¯¥å›¾è¿›è¡Œæ‹“æ‰‘æ’åºï¼Œç„¶åæ ¹æ®æ‹“æ‰‘æ’åºçš„ç»“æœï¼Œä½¿ç”¨åŠ¨æ€è§„åˆ’æ±‚å‡ºå®Œæˆæ‰€æœ‰è¯¾ç¨‹æ‰€éœ€è¦çš„æœ€å°‘æ—¶é—´ã€‚

æˆ‘ä»¬å®šä¹‰ä»¥ä¸‹å‡ ä¸ªæ•°æ®ç»“æ„æˆ–å˜é‡ï¼š

- é‚»æ¥è¡¨ $g$ å­˜å‚¨æœ‰å‘æ— ç¯å›¾ï¼ŒåŒæ—¶ä½¿ç”¨ä¸€ä¸ªæ•°ç»„ $indeg$ å­˜å‚¨æ¯ä¸ªèŠ‚ç‚¹çš„å…¥åº¦ï¼›
- é˜Ÿåˆ— $q$ å­˜å‚¨æ‰€æœ‰å…¥åº¦ä¸º $0$ çš„èŠ‚ç‚¹ï¼›
- æ•°ç»„ $f$ å­˜å‚¨æ¯ä¸ªèŠ‚ç‚¹çš„æœ€æ—©å®Œæˆæ—¶é—´ï¼Œåˆå§‹æ—¶ $f[i] = 0$ï¼›
- å˜é‡ $ans$ è®°å½•æœ€ç»ˆçš„ç­”æ¡ˆï¼Œåˆå§‹æ—¶ $ans = 0$ï¼›

å½“ $q$ éç©ºæ—¶ï¼Œä¾æ¬¡å–å‡ºé˜Ÿé¦–èŠ‚ç‚¹ $i$ï¼Œéå† $g[i]$ ä¸­çš„æ¯ä¸ªèŠ‚ç‚¹ $j$ï¼Œæ›´æ–° $f[j] = max(f[j], f[i] + time[j])$ï¼ŒåŒæ—¶æ›´æ–° $ans = \max(ans, f[j])$ï¼Œå¹¶å°† $j$ çš„å…¥åº¦å‡ $1$ï¼Œå¦‚æœæ­¤æ—¶ $j$ çš„å…¥åº¦ä¸º $0$ï¼Œåˆ™å°† $j$ åŠ å…¥é˜Ÿåˆ— $q$ ä¸­ï¼›

æœ€ç»ˆè¿”å› $ans$ã€‚

* [sol1-Python3]

```python
class Solution:
    def minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:
        g = defaultdict(list)
        indeg = [0] * n
        for a, b in relations:
            g[a - 1].append(b - 1)
            indeg[b - 1] += 1
        q = deque()
        f = [0] * n
        ans = 0
        for i, (v, t) in enumerate(zip(indeg, time)):
            if v == 0:
                q.append(i)
                f[i] = t
                ans = max(ans, t)
        while q:
            i = q.popleft()
            for j in g[i]:
                f[j] = max(f[j], f[i] + time[j])
                ans = max(ans, f[j])
                indeg[j] -= 1
                if indeg[j] == 0:
                    q.append(j)
        return ans
```

* [sol1-Java]

```java
class Solution {
    public int minimumTime(int n, int[][] relations, int[] time) {
        List<Integer>[] g = new List[n];
        Arrays.setAll(g, k -> new ArrayList<>());
        int[] indeg = new int[n];
        for (int[] e : relations) {
            int a = e[0] - 1, b = e[1] - 1;
            g[a].add(b);
            ++indeg[b];
        }
        Deque<Integer> q = new ArrayDeque<>();
        int[] f = new int[n];
        int ans = 0;
        for (int i = 0; i < n; ++i) {
            int v = indeg[i], t = time[i];
            if (v == 0) {
                q.offer(i);
                f[i] = t;
                ans = Math.max(ans, t);
            }
        }
        while (!q.isEmpty()) {
            int i = q.pollFirst();
            for (int j : g[i]) {
                f[j] = Math.max(f[j], f[i] + time[j]);
                ans = Math.max(ans, f[j]);
                if (--indeg[j] == 0) {
                    q.offer(j);
                }
            }
        }
        return ans;
    }
}
```

* [sol1-C++]

```cpp
class Solution {
public:
    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {
        vector<vector<int>> g(n);
        vector<int> indeg(n);
        for (auto& e : relations) {
            int a = e[0] - 1, b = e[1] - 1;
            g[a].push_back(b);
            ++indeg[b];
        }
        queue<int> q;
        vector<int> f(n);
        int ans = 0;
        for (int i = 0; i < n; ++i) {
            int v = indeg[i], t = time[i];
            if (v == 0) {
                q.push(i);
                f[i] = t;
                ans = max(ans, t);
            }
        }
        while (!q.empty()) {
            int i = q.front();
            q.pop();
            for (int j : g[i]) {
                if (--indeg[j] == 0) {
                    q.push(j);
                }
                f[j] = max(f[j], f[i] + time[j]);
                ans = max(ans, f[j]);
            }
        }
        return ans;
    }
};
```

* [sol1-Go]

```go
func minimumTime(n int, relations [][]int, time []int) int {
	g := make([][]int, n)
	indeg := make([]int, n)
	for _, e := range relations {
		a, b := e[0]-1, e[1]-1
		g[a] = append(g[a], b)
		indeg[b]++
	}
	f := make([]int, n)
	q := []int{}
	ans := 0
	for i, v := range indeg {
		if v == 0 {
			q = append(q, i)
			f[i] = time[i]
			ans = max(ans, time[i])
		}
	}
	for len(q) > 0 {
		i := q[0]
		q = q[1:]
		for _, j := range g[i] {
			indeg[j]--
			if indeg[j] == 0 {
				q = append(q, j)
			}
			f[j] = max(f[j], f[i]+time[j])
			ans = max(ans, f[j])
		}
	}
	return ans
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}
```

* [sol1-TypeScript]

```ts
function minimumTime(n: number, relations: number[][], time: number[]): number {
    const g: number[][] = Array(n)
        .fill(0)
        .map(() => []);
    const indeg: number[] = Array(n).fill(0);
    for (const [a, b] of relations) {
        g[a - 1].push(b - 1);
        ++indeg[b - 1];
    }
    const q: number[] = [];
    const f: number[] = Array(n).fill(0);
    let ans: number = 0;
    for (let i = 0; i < n; ++i) {
        if (indeg[i] === 0) {
            q.push(i);
            f[i] = time[i];
            ans = Math.max(ans, f[i]);
        }
    }
    while (q.length > 0) {
        const i = q.shift()!;
        for (const j of g[i]) {
            f[j] = Math.max(f[j], f[i] + time[j]);
            ans = Math.max(ans, f[j]);
            if (--indeg[j] === 0) {
                q.push(j);
            }
        }
    }
    return ans;
}
```

æ—¶é—´å¤æ‚åº¦ $O(m + n)$ï¼Œç©ºé—´å¤æ‚åº¦ $O(m + n)$ã€‚å…¶ä¸­ $m$ æ˜¯æ•°ç»„ $relations$ çš„é•¿åº¦ã€‚

---

æœ‰ä»»ä½•é—®é¢˜ï¼Œæ¬¢è¿è¯„è®ºåŒºäº¤æµï¼Œæ¬¢è¿è¯„è®ºåŒºæä¾›å…¶å®ƒè§£é¢˜æ€è·¯ï¼ˆä»£ç ï¼‰ï¼Œä¹Ÿå¯ä»¥ç‚¹ä¸ªèµæ”¯æŒä¸€ä¸‹ä½œè€…å“ˆğŸ˜„~
