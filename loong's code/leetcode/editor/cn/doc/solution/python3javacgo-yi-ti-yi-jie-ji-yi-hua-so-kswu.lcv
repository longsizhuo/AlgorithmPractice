### æ–¹æ³•ä¸€ï¼šè®°å¿†åŒ–æœç´¢

æˆ‘ä»¬å¯ä»¥è€ƒè™‘æ¯ä¸€å µå¢™æ˜¯ç»™ä»˜è´¹æ²¹æ¼†åŒ åˆ·è¿˜æ˜¯ç»™å…è´¹æ²¹æ¼†åŒ åˆ·ï¼Œè®¾è®¡ä¸€ä¸ªå‡½æ•° $dfs(i, j)$ï¼Œè¡¨ç¤ºä»Žç¬¬ $i$ å µå¢™å¼€å§‹ï¼Œä¸”å½“å‰å‰©ä½™çš„å…è´¹æ²¹æ¼†åŒ å·¥ä½œæ—¶é—´ä¸º $j$ æ—¶ï¼Œåˆ·å®Œå‰©ä½™æ‰€æœ‰å¢™å£çš„æœ€å°å¼€é”€ã€‚é‚£ä¹ˆç­”æ¡ˆä¸º $dfs(0, 0)$ã€‚

å‡½æ•° $dfs(i, j)$ çš„è®¡ç®—è¿‡ç¨‹å¦‚ä¸‹ï¼š

- å¦‚æžœ $n - i \le j$ï¼Œè¡¨ç¤ºå‰©ä½™çš„å¢™å£ä¸è¶…è¿‡å…è´¹æ²¹æ¼†åŒ çš„å·¥ä½œæ—¶é—´ï¼Œé‚£ä¹ˆå‰©ä½™çš„å¢™å£éƒ½ç”±å…è´¹æ²¹æ¼†åŒ åˆ·ï¼Œå¼€é”€ä¸º $0$ï¼›
- å¦‚æžœ $i \ge n$ï¼Œè¿”å›ž $+\infty$ï¼›
- å¦åˆ™ï¼Œå¦‚æžœç¬¬ $i$ å µå¢™ç”±ä»˜è´¹æ²¹æ¼†åŒ åˆ·ï¼Œå¼€é”€ä¸º $cost[i]$ï¼Œé‚£ä¹ˆ $dfs(i, j) = dfs(i + 1, j + time[i]) + cost[i]$ï¼›å¦‚æžœç¬¬ $i$ å µå¢™ç”±å…è´¹æ²¹æ¼†åŒ åˆ·ï¼Œå¼€é”€ä¸º $0$ï¼Œé‚£ä¹ˆ $dfs(i, j) = dfs(i + 1, j - 1)$ã€‚

æ³¨æ„ï¼Œå‚æ•° $j$ å¯èƒ½å°äºŽ $0$ï¼Œå› æ­¤ï¼Œåœ¨å®žé™…ç¼–ç è¿‡ç¨‹ä¸­ï¼Œé™¤äº† $Python$ è¯­è¨€å¤–ï¼Œæˆ‘ä»¬å¯¹ $j$ åŠ ä¸Šä¸€ä¸ªåç§»é‡ $n$ï¼Œä½¿å¾— $j$ çš„å–å€¼èŒƒå›´ä¸º $[0, 2n]$ã€‚

* [sol1-Python3]

```python
class Solution:
    def paintWalls(self, cost: List[int], time: List[int]) -> int:
        @cache
        def dfs(i: int, j: int) -> int:
            if n - i <= j:
                return 0
            if i >= n:
                return inf
            return min(dfs(i + 1, j + time[i]) + cost[i], dfs(i + 1, j - 1))

        n = len(cost)
        return dfs(0, 0)
```

* [sol1-Java]

```java
class Solution {
    private int n;
    private int[] cost;
    private int[] time;
    private Integer[][] f;

    public int paintWalls(int[] cost, int[] time) {
        n = cost.length;
        this.cost = cost;
        this.time = time;
        f = new Integer[n][n << 1 | 1];
        return dfs(0, n);
    }

    private int dfs(int i, int j) {
        if (n - i <= j - n) {
            return 0;
        }
        if (i >= n) {
            return 1 << 30;
        }
        if (f[i][j] == null) {
            f[i][j] = Math.min(dfs(i + 1, j + time[i]) + cost[i], dfs(i + 1, j - 1));
        }
        return f[i][j];
    }
}
```

* [sol1-C++]

```cpp
class Solution {
public:
    int paintWalls(vector<int>& cost, vector<int>& time) {
        int n = cost.size();
        int f[n][n << 1 | 1];
        memset(f, -1, sizeof(f));
        function<int(int, int)> dfs = [&](int i, int j) -> int {
            if (n - i <= j - n) {
                return 0;
            }
            if (i >= n) {
                return 1 << 30;
            }
            if (f[i][j] == -1) {
                f[i][j] = min(dfs(i + 1, j + time[i]) + cost[i], dfs(i + 1, j - 1));
            }
            return f[i][j];
        };
        return dfs(0, n);
    }
};
```

* [sol1-Go]

```go
func paintWalls(cost []int, time []int) int {
	n := len(cost)
	f := make([][]int, n)
	for i := range f {
		f[i] = make([]int, n<<1|1)
		for j := range f[i] {
			f[i][j] = -1
		}
	}
	var dfs func(i, j int) int
	dfs = func(i, j int) int {
		if n-i <= j-n {
			return 0
		}
		if i >= n {
			return 1 << 30
		}
		if f[i][j] == -1 {
			f[i][j] = min(dfs(i+1, j+time[i])+cost[i], dfs(i+1, j-1))
		}
		return f[i][j]
	}
	return dfs(0, n)
}
```

æ—¶é—´å¤æ‚åº¦ $O(n^2)$ï¼Œç©ºé—´å¤æ‚åº¦ $O(n^2)$ã€‚å…¶ä¸­ $n$ ä¸ºæ•°ç»„é•¿åº¦ã€‚

---

æœ‰ä»»ä½•é—®é¢˜ï¼Œæ¬¢è¿Žè¯„è®ºåŒºäº¤æµï¼Œæ¬¢è¿Žè¯„è®ºåŒºæä¾›å…¶å®ƒè§£é¢˜æ€è·¯ï¼ˆä»£ç ï¼‰ï¼Œä¹Ÿå¯ä»¥ç‚¹ä¸ªèµžæ”¯æŒä¸€ä¸‹ä½œè€…å“ˆðŸ˜„~
