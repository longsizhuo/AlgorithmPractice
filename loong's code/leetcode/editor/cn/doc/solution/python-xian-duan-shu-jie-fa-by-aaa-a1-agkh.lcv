> Problem: [407. æ¥é›¨æ°´ II](https://leetcode.cn/problems/trapping-rain-water-ii/description/)

[TOC]

# æ€è·¯

æœ¬é¢˜æœ€ç®€å•çš„æ€ç»´å°±æ˜¯å°†ä¸‰ç»´è½¬æˆäºŒç»´ä¸€å±‚ä¸€å±‚çš„æ±‚è§£ï¼Œ
äºŒç»´çš„è§£æ³•å°±æ˜¯ [å²›å±¿çš„æœ€å¤§é¢ç§¯](https://leetcode.cn/problems/ZL6zAn/) è¿™é¢˜æ€è·¯ç±»ä¼¼, ä¸è¿‡æˆ‘ä»¬æ±‚çš„æ˜¯æ€»é¢ç§¯ ï¼ˆæ€»é¢ç§¯ = é•¿ * å®½ - æŸ±å­æ•°é‡ - ä¸æ°´è”é€šçš„ç©ºåœ°ï¼‰
ç„¶åæŸ±å­åœ¨æ¯ä¸€å±‚çš„é¢ç§¯å¯ä»¥ä½¿ç”¨çº¿æ®µï¼ˆæ ‘æ¡©æ•°ç»„ï¼‰åŒºé—´åŠ æ³•ã€‚æ±‚å‡ºæ¥

æ€è·¯è®²è§£å®Œæ¯•

æœ´ç´ è§£æ³•çš„æ—¶é—´å¤æ‚åº¦æ˜¯ 10^4 x (mn + log(10^4))  è¿™ä¸ªå¤æ‚åº¦ä¼šè¶…æ—¶æ˜¯ä¸èƒ½æ¥å—çš„
ä¸‹é¢è®²è§£ä¸€äº›ä¼˜åŒ–ï¼š
1. å› ä¸ºæŸ±å­çš„é«˜åº¦æ˜¯è¿ç»­çš„ä¸å­˜åœ¨ä¸­é—´ç¼ºä¸€äº›çš„æƒ…å†µæ‰€ä»¥æˆ‘ä»¬å¯ä»¥æœé›†æ‰€æœ‰çš„é«˜åº¦æ’åºï¼Œéå†ï¼Œï¼ˆä¸¤ä¸ªè¿ç»­é«˜åº¦ a, b ; a < bï¼‰ä¸­é—´çš„é«˜åº¦(a ~ b)çš„é¢ç§¯éƒ½æ˜¯å’Œbç­”æ¡ˆä¸€æ ·çš„ã€‚è¿™æ ·å°±å¯ä»¥å°†å¤æ‚åº¦ä¼˜åŒ–åˆ° mn x (mn + log(10^4))
2. å› ä¸ºæŸ±å­çš„é«˜åº¦æ˜¯è¿ç»­çš„ æ‰€ä»¥æˆ‘ä»¬æ¯å±‚ bfs æ±‚ä¸æ°´ç›¸è¿çš„é¢ç§¯ä¸ç”¨é‡å¤´å¼€å§‹æ±‚ï¼Œè€Œæ˜¯å¯ä»¥ä¿ç•™ä¸Šä¸€æ¬¡çš„é¢ç»“ç»“æœï¼Œç„¶åæ‰¾åˆ°è¿™ä¸€å±‚æ¯”ä¸Šä¸€å±‚æ–°å¢ç©ºåœ°ï¼ˆå°±æ˜¯é¢ç§¯ç­‰äºä¸Šä¸€å±‚çš„é‚£äº›ç‚¹ï¼‰å¼€å§‹ bfs
   è¿™æ ·æ—¶é—´å¤æ‚åº¦å¯ä»¥å‡æ‘Šä¼˜åŒ–åˆ° mn x  (log(10^4))

ä»£ç å†™çš„æœ‰ç‚¹ä¹±ï¼Œæ²¡æœ‰ä¼˜åŒ– ğŸ˜…

# è§£é¢˜æ–¹æ³•

> æè¿°ä½ çš„è§£é¢˜æ–¹æ³•

# å¤æ‚åº¦

æ—¶é—´å¤æ‚åº¦:

> æ·»åŠ æ—¶é—´å¤æ‚åº¦, ç¤ºä¾‹ï¼š $O(n)$

ç©ºé—´å¤æ‚åº¦:

> æ·»åŠ ç©ºé—´å¤æ‚åº¦, ç¤ºä¾‹ï¼š $O(n)$

# Code

* []

```Python
from collections import defaultdict
from typing import List


class Tree:
    def __init__(self, len) -> None:
        self.st = [0] * (4 * len + 4)
        self.lazy = [0] * (4 * len + 4)

    def pushdown(self, node):
        val = self.lazy[node]
        if not val:
            return

        self.st[node * 2] += val
        self.st[node * 2 + 1] += val
        self.lazy[node * 2] += val
        self.lazy[node * 2 + 1] += val
        self.lazy[node] = 0

    def update(self, L, R, val, node, l, r):
        if r < L or l > R:
            return
        if L <= l and r <= R:
            self.st[node] += val
            if l != r:
                self.lazy[node] += val
            return

        self.pushdown(node)

        mid = (l + r) // 2
        self.update(L, R, val, node * 2, l, mid)
        self.update(L, R, val, node * 2 + 1, mid + 1, r)
        self.st[node] = self.st[node * 2] + self.st[node * 2 + 1]

    def query(self, index, node, l, r):
        if index < l or index > r:
            return 0
        if l == r:
            if l == index:
                return self.st[node]
            return 0

        self.pushdown(node)

        mid = (l + r) // 2
        return self.query(index, node * 2, l, mid) + self.query(
            index, node * 2 + 1, mid + 1, r
        )


class Solution:
    def trapRainWater(self, heightMap: List[List[int]]) -> int:
        heights = set()
        m = len(heightMap)
        n = len(heightMap[0])

        mh = 0
        countMap = defaultdict(set)
        visited = set()

        for i in range(m):
            for j in range(n):
                mh = heightMap[i][j] + 1 if heightMap[i][j] > mh else mh
                heights.add(heightMap[i][j])
                countMap[heightMap[i][j]].add((i, j))

        st = Tree(mh)
        for i, j in countMap.items():
            st.update(0, i, len(j), 1, 0, mh)

        heights = sorted(list(heights))

        res = 0
        preH = heights[0]
        for h in heights:
            count = st.query(h, 1, 0, mh)
            print(h, count)
            if count >= 4 and count != m * n:
                ep = self.calc(heightMap, h, m, n, visited, countMap[preH])
                res += (h - preH) * (m * n - (ep) - count)
            preH = h
        return res

    def calc(self, ls, h, m, n, visited: set, add: set):
        queue = []
        for i in range(m):
            if (i, 0) not in visited and ls[i][0] < h:
                queue.append((i, 0))
                visited.add((i, 0))

            if (i, n - 1) not in visited and ls[i][n - 1] < h:
                queue.append((i, n - 1))
                visited.add((i, n - 1))
        for i in range(n):
            if (0, i) not in visited and ls[0][i] < h:
                queue.append((0, i))
                visited.add((0, i))

            if (m - 1, i) not in visited and ls[m - 1][i] < h:
                queue.append((m - 1, i))
                visited.add((m - 1, i))

        # åœ¨é›†åˆç§çš„èŠ‚ç‚¹å†æ¬¡éå†å››å‘¨çš„ç‚¹
        for i, j in add:
            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                nx, ny = i + dx, j + dy
                if nx < 0 or nx >= m or ny < 0 or ny >= n:
                    continue
                # å½“æ–°å¢çš„èŠ‚ç‚¹å’Œå·²ç»éå†çš„èŠ‚ç‚¹ç›¸é‚»æ—¶ï¼Œå°†å…¶åŠ å…¥é˜Ÿåˆ—
                if (nx, ny) in visited:
                    queue.append((i, j))
                    visited.add((i, j))
                    break

        while queue:
            x, y = queue.pop()
            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                nx, ny = x + dx, y + dy
                if nx < 0 or nx >= m or ny < 0 or ny >= n:
                    continue
                if (nx, ny) in visited:
                    continue

                if ls[nx][ny] < h:
                    visited.add((nx, ny))
                    queue.append((nx, ny))

        return len(visited)
```

