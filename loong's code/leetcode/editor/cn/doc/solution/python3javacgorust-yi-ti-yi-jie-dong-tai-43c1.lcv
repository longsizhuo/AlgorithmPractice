**ÊñπÊ≥ï‰∏ÄÔºöÂä®ÊÄÅËßÑÂàí**

Êàë‰ª¨ÂÆö‰πâ‰ª•‰∏ãÂá†‰∏™ÂèòÈáèÔºåÂÖ∂‰∏≠Ôºö

- $f_1$ Ë°®Á§∫Á¨¨‰∏ÄÊ¨°‰π∞ÂÖ•ËÇ°Á•®ÂêéÁöÑÊúÄÂ§ßÂà©Ê∂¶Ôºõ
- $f_2$ Ë°®Á§∫Á¨¨‰∏ÄÊ¨°ÂçñÂá∫ËÇ°Á•®ÂêéÁöÑÊúÄÂ§ßÂà©Ê∂¶Ôºõ
- $f_3$ Ë°®Á§∫Á¨¨‰∫åÊ¨°‰π∞ÂÖ•ËÇ°Á•®ÂêéÁöÑÊúÄÂ§ßÂà©Ê∂¶Ôºõ
- $f_4$ Ë°®Á§∫Á¨¨‰∫åÊ¨°ÂçñÂá∫ËÇ°Á•®ÂêéÁöÑÊúÄÂ§ßÂà©Ê∂¶„ÄÇ

ÈÅçÂéÜËøáÁ®ã‰∏≠ÔºåÁõ¥Êé•‰ΩøÁî® $f_1$, $f_2$, $f_3$, $f_4$ ËÆ°ÁÆóÔºåËÄÉËôëÁöÑÊòØÂú®Âêå‰∏ÄÂ§©‰π∞ÂÖ•ÂíåÂçñÂá∫Êó∂ÔºåÊî∂ÁõäÊòØ $0$Ôºå‰∏ç‰ºöÂØπÁ≠îÊ°à‰∫ßÁîüÂΩ±Âìç„ÄÇ

ÊúÄÂêéËøîÂõû $f_4$ Âç≥ÂèØ„ÄÇ

* [sol1-Python3]

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        # Á¨¨‰∏ÄÊ¨°‰π∞ÂÖ•ÔºåÁ¨¨‰∏ÄÊ¨°ÂçñÂá∫ÔºåÁ¨¨‰∫åÊ¨°‰π∞ÂÖ•ÔºåÁ¨¨‰∫åÊ¨°ÂçñÂá∫
        f1, f2, f3, f4 = -prices[0], 0, -prices[0], 0
        for price in prices[1:]:
            f1 = max(f1, -price)
            f2 = max(f2, f1 + price)
            f3 = max(f3, f2 - price)
            f4 = max(f4, f3 + price)
        return f4
```

* [sol1-Java]

```java
class Solution {
    public int maxProfit(int[] prices) {
        // Á¨¨‰∏ÄÊ¨°‰π∞ÂÖ•ÔºåÁ¨¨‰∏ÄÊ¨°ÂçñÂá∫ÔºåÁ¨¨‰∫åÊ¨°‰π∞ÂÖ•ÔºåÁ¨¨‰∫åÊ¨°ÂçñÂá∫
        int f1 = -prices[0], f2 = 0, f3 = -prices[0], f4 = 0;
        for (int i = 1; i < prices.length; ++i) {
            f1 = Math.max(f1, -prices[i]);
            f2 = Math.max(f2, f1 + prices[i]);
            f3 = Math.max(f3, f2 - prices[i]);
            f4 = Math.max(f4, f3 + prices[i]);
        }
        return f4;
    }
}
```

* [sol1-C++]

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int f1 = -prices[0], f2 = 0, f3 = -prices[0], f4 = 0;
        for (int i = 1; i < prices.size(); ++i) {
            f1 = max(f1, -prices[i]);
            f2 = max(f2, f1 + prices[i]);
            f3 = max(f3, f2 - prices[i]);
            f4 = max(f4, f3 + prices[i]);
        }
        return f4;
    }
};
```

* [sol1-Go]

```go
func maxProfit(prices []int) int {
	f1, f2, f3, f4 := -prices[0], 0, -prices[0], 0
	for i := 1; i < len(prices); i++ {
		f1 = max(f1, -prices[i])
		f2 = max(f2, f1+prices[i])
		f3 = max(f3, f2-prices[i])
		f4 = max(f4, f3+prices[i])
	}
	return f4
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}
```

* [sol1-Rust]

```rust
impl Solution {
    #[allow(dead_code)]
    pub fn max_profit(prices: Vec<i32>) -> i32 {
        let mut f1 = -prices[0];
        let mut f2 = 0;
        let mut f3 = -prices[0];
        let mut f4 = 0;
        let n = prices.len();

        for i in 1..n {
            f1 = std::cmp::max(f1, -prices[i]);
            f2 = std::cmp::max(f2, f1 + prices[i]);
            f3 = std::cmp::max(f3, f2 - prices[i]);
            f4 = std::cmp::max(f4, f3 + prices[i]);
        }

        f4
    }
}
```

* [sol1-TypeScript]

```ts
function maxProfit(prices: number[]): number {
    let [f1, f2, f3, f4] = [-prices[0], 0, -prices[0], 0];
    for (let i = 1; i < prices.length; ++i) {
        f1 = Math.max(f1, -prices[i]);
        f2 = Math.max(f2, f1 + prices[i]);
        f3 = Math.max(f3, f2 - prices[i]);
        f4 = Math.max(f4, f3 + prices[i]);
    }
    return f4;
}
```

* [sol1-C#]

```cs
public class Solution {
    public int MaxProfit(int[] prices) {
        int f1 = -prices[0], f2 = 0, f3 = -prices[0], f4 = 0;
        for (int i = 1; i < prices.Length; ++i) {
            f1 = Math.Max(f1, -prices[i]);
            f2 = Math.Max(f2, f1 + prices[i]);
            f3 = Math.Max(f3, f2 - prices[i]);
            f4 = Math.Max(f4, f3 + prices[i]);
        }
        return f4;
    }
}
```

Êó∂Èó¥Â§çÊùÇÂ∫¶ $O(n)$ÔºåÂÖ∂‰∏≠ $n$ ‰∏∫Êï∞ÁªÑ $prices$ ÁöÑÈïøÂ∫¶„ÄÇÁ©∫Èó¥Â§çÊùÇÂ∫¶ $O(1)$„ÄÇ

---

Êúâ‰ªª‰ΩïÈóÆÈ¢òÔºåÊ¨¢ËøéËØÑËÆ∫Âå∫‰∫§ÊµÅÔºåÊ¨¢ËøéËØÑËÆ∫Âå∫Êèê‰æõÂÖ∂ÂÆÉËß£È¢òÊÄùË∑ØÔºà‰ª£Á†ÅÔºâÔºå‰πüÂèØ‰ª•ÁÇπ‰∏™ËµûÊîØÊåÅ‰∏Ä‰∏ã‰ΩúËÄÖÂìàüòÑ~
