**æ–¹æ³•ä¸€ï¼šè´ªå¿ƒ + ä¼˜å…ˆé˜Ÿåˆ—ï¼ˆå¤§æ ¹å †ï¼‰**

æ ¹æ®é¢˜ç›®æè¿°ï¼Œæ¯ä¸€æ¬¡æ“ä½œï¼Œéƒ½ä¼šå°†æ•°ç»„ä¸­çš„ä¸€ä¸ªæ•°å‡åŠã€‚è¦ä½¿å¾—æ•°ç»„å’Œè‡³å°‘å‡å°‘ä¸€åŠçš„æ“ä½œæ¬¡æ•°æœ€å°‘ï¼Œé‚£ä¹ˆæ¯ä¸€æ¬¡æ“ä½œéƒ½åº”è¯¥é€‰æ‹©å½“å‰æ•°ç»„ä¸­çš„æœ€å¤§å€¼è¿›è¡Œå‡åŠã€‚

å› æ­¤ï¼Œæˆ‘ä»¬å…ˆç®—å‡ºæ•°ç»„è¦å‡å°‘çš„æ€»å’Œ $s$ï¼Œç„¶åç”¨ä¸€ä¸ªä¼˜å…ˆé˜Ÿåˆ—ï¼ˆå¤§æ ¹å †ï¼‰ç»´æŠ¤æ•°ç»„ä¸­çš„æ‰€æœ‰æ•°ï¼Œæ¯æ¬¡ä»ä¼˜å…ˆé˜Ÿåˆ—ä¸­å–å‡ºæœ€å¤§å€¼ $t$ï¼Œå°†å…¶å‡åŠï¼Œç„¶åå°†å‡åŠåçš„æ•°é‡æ–°æ”¾å…¥ä¼˜å…ˆé˜Ÿåˆ—ä¸­ï¼ŒåŒæ—¶æ›´æ–° $s$ï¼Œç›´åˆ° $s \le 0$ ä¸ºæ­¢ã€‚é‚£ä¹ˆæ­¤æ—¶çš„æ“ä½œæ¬¡æ•°å°±æ˜¯ç­”æ¡ˆã€‚

* [sol1-Python3]

```python
class Solution:
    def halveArray(self, nums: List[int]) -> int:
        s = sum(nums) / 2
        h = []
        for v in nums:
            heappush(h, -v)
        ans = 0
        while s > 0:
            t = -heappop(h) / 2
            s -= t
            heappush(h, -t)
            ans += 1
        return ans
```

* [sol1-Java]

```java
class Solution {
    public int halveArray(int[] nums) {
        double s = 0;
        PriorityQueue<Double> q = new PriorityQueue<>(Collections.reverseOrder());
        for (int v : nums) {
            q.offer(v * 1.0);
            s += v;
        }
        s /= 2.0;
        int ans = 0;
        while (s > 0) {
            double t = q.poll();
            s -= t / 2.0;
            q.offer(t / 2.0);
            ++ans;
        }
        return ans;
    }
}
```

* [sol1-C++]

```cpp
class Solution {
public:
    int halveArray(vector<int>& nums) {
        priority_queue<double> q;
        double s = 0;
        for (int& v : nums) {
            s += v;
            q.push(v);
        }
        s /= 2.0;
        int ans = 0;
        while (s > 0) {
            double t = q.top() / 2;
            q.pop();
            s -= t;
            q.push(t);
            ++ans;
        }
        return ans;
    }
};
```

* [sol1-Go]

```go
func halveArray(nums []int) (ans int) {
	var s float64
	q := hp{}
	for _, x := range nums {
		s += float64(x)
		heap.Push(&q, float64(x))
	}
	s /= 2
	for s > 0 {
		x := heap.Pop(&q).(float64)
		ans++
		s -= x / 2
		heap.Push(&q, x/2)
	}
	return
}

type hp struct{ sort.Float64Slice }

func (h hp) Less(i, j int) bool  { return h.Float64Slice[i] > h.Float64Slice[j] }
func (h *hp) Push(v interface{}) { h.Float64Slice = append(h.Float64Slice, v.(float64)) }
func (h *hp) Pop() interface{} {
	a := h.Float64Slice
	v := a[len(a)-1]
	h.Float64Slice = a[:len(a)-1]
	return v
}
```

* [sol1-TypeScript]

```ts
function halveArray(nums: number[]): number {
    let s: number = nums.reduce((a, b) => a + b) / 2;
    const h = new MaxPriorityQueue();
    for (const v of nums) {
        h.enqueue(v, v);
    }
    let ans: number = 0;
    while (s > 0) {
        let { element: t } = h.dequeue();
        t /= 2;
        s -= t;
        h.enqueue(t, t);
        ans += 1;
    }
    return ans;
}
```

æ—¶é—´å¤æ‚åº¦ $O(n \times \log n)$ï¼Œç©ºé—´å¤æ‚åº¦ $O(n)$ã€‚å…¶ä¸­ $n$ æ˜¯æ•°ç»„çš„é•¿åº¦ã€‚

---

æœ‰ä»»ä½•é—®é¢˜ï¼Œæ¬¢è¿è¯„è®ºåŒºäº¤æµï¼Œæ¬¢è¿è¯„è®ºåŒºæä¾›å…¶å®ƒè§£é¢˜æ€è·¯ï¼ˆä»£ç ï¼‰ï¼Œä¹Ÿå¯ä»¥ç‚¹ä¸ªèµæ”¯æŒä¸€ä¸‹ä½œè€…å“ˆğŸ˜„~
