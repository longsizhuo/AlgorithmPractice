**æ–¹æ³•ä¸€ï¼šè´ªå¿ƒ**

ä»ç¬¬äºŒå¤©å¼€å§‹ï¼Œå¦‚æœå½“å¤©è‚¡ä»·å¤§äºå‰ä¸€å¤©è‚¡ä»·ï¼Œåˆ™åœ¨å‰ä¸€å¤©ä¹°å…¥ï¼Œå½“å¤©å–å‡ºï¼Œå³å¯è·å¾—åˆ©æ¶¦ã€‚å¦‚æœå½“å¤©è‚¡ä»·å°äºå‰ä¸€å¤©è‚¡ä»·ï¼Œåˆ™ä¸ä¹°å…¥ï¼Œä¸å–å‡ºã€‚ä¹Ÿå³æ˜¯è¯´ï¼Œæ‰€æœ‰ä¸Šæ¶¨äº¤æ˜“æ—¥éƒ½åšä¹°å–ï¼Œæ‰€æœ‰ä¸‹è·Œäº¤æ˜“æ—¥éƒ½ä¸åšä¹°å–ï¼Œæœ€ç»ˆè·å¾—çš„åˆ©æ¶¦æ˜¯æœ€å¤§çš„ã€‚

* [sol1-Python3]

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        return sum(max(0, b - a) for a, b in pairwise(prices))
```

* [sol1-Java]

```java
class Solution {
    public int maxProfit(int[] prices) {
        int ans = 0;
        for (int i = 1; i < prices.length; ++i) {
            ans += Math.max(0, prices[i] - prices[i - 1]);
        }
        return ans;
    }
}
```

* [sol1-C++]

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int ans = 0;
        for (int i = 1; i < prices.size(); ++i) ans += max(0, prices[i] - prices[i - 1]);
        return ans;
    }
};
```

* [sol1-Go]

```go
func maxProfit(prices []int) (ans int) {
	for i, v := range prices[1:] {
		t := v - prices[i]
		if t > 0 {
			ans += t
		}
	}
	return
}
```

æ—¶é—´å¤æ‚åº¦ $O(n)$ï¼Œå…¶ä¸­ $n$ ä¸ºæ•°ç»„ `prices` çš„é•¿åº¦ã€‚ç©ºé—´å¤æ‚åº¦ $O(1)$ã€‚

------

**æ–¹æ³•äºŒï¼šåŠ¨æ€è§„åˆ’**

æˆ‘ä»¬è®¾ $f[i][j]$ è¡¨ç¤ºç¬¬ $i$ å¤©äº¤æ˜“å®Œåçš„æœ€å¤§åˆ©æ¶¦ï¼Œå…¶ä¸­ $j$ è¡¨ç¤ºå½“å‰æ˜¯å¦æŒæœ‰è‚¡ç¥¨ï¼ŒæŒæœ‰è‚¡ç¥¨æ—¶ $j=0$ï¼Œä¸æŒæœ‰è‚¡ç¥¨æ—¶ $j=1$ã€‚åˆå§‹çŠ¶æ€ä¸º $f[0][0]=-prices[0]$ï¼Œå…¶ä½™çŠ¶æ€å‡ä¸º $0$ã€‚

å¦‚æœå½“å‰æŒæœ‰è‚¡ç¥¨ï¼Œé‚£ä¹ˆå¯èƒ½æ˜¯å‰ä¸€å¤©å°±æŒæœ‰è‚¡ç¥¨ï¼Œä»Šå¤©ä»€ä¹ˆéƒ½ä¸åšï¼Œå³ $f[i][0]=f[i-1][0]$ï¼›ä¹Ÿå¯èƒ½æ˜¯å‰ä¸€å¤©ä¸æŒæœ‰è‚¡ç¥¨ï¼Œä»Šå¤©ä¹°å…¥è‚¡ç¥¨ï¼Œå³ $f[i][0]=f[i-1][1]-prices[i]$ã€‚

å¦‚æœå½“å‰ä¸æŒæœ‰è‚¡ç¥¨ï¼Œé‚£ä¹ˆå¯èƒ½æ˜¯å‰ä¸€å¤©å°±ä¸æŒæœ‰è‚¡ç¥¨ï¼Œä»Šå¤©ä»€ä¹ˆéƒ½ä¸åšï¼Œå³ $f[i][1]=f[i-1][1]$ï¼›ä¹Ÿå¯èƒ½æ˜¯å‰ä¸€å¤©æŒæœ‰è‚¡ç¥¨ï¼Œä»Šå¤©å–å‡ºè‚¡ç¥¨ï¼Œå³ $f[i][1]=f[i-1][0]+prices[i]$ã€‚

å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥å†™å‡ºçŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼š

$$
\begin{cases}
f[i][0]=\max(f[i-1][0],f[i-1][1]-prices[i])\\
f[i][1]=\max(f[i-1][1],f[i-1][0]+prices[i])
\end{cases}
$$

æœ€ç»ˆçš„ç­”æ¡ˆå³ä¸º $f[n-1][1]$ï¼Œå…¶ä¸­ $n$ ä¸ºæ•°ç»„ `prices` çš„é•¿åº¦ã€‚

æ—¶é—´å¤æ‚åº¦ $O(n)$ï¼Œç©ºé—´å¤æ‚åº¦ $O(n)$ã€‚å…¶ä¸­ $n$ ä¸ºæ•°ç»„ `prices` çš„é•¿åº¦ã€‚

* [sol2-Python3]

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n = len(prices)
        f = [[0] * 2 for _ in range(n)]
        f[0][0] = -prices[0]
        for i in range(1, n):
            f[i][0] = max(f[i - 1][0], f[i - 1][1] - prices[i])
            f[i][1] = max(f[i - 1][1], f[i - 1][0] + prices[i])
        return f[n - 1][1]
```

* [sol2-Java]

```java
class Solution {
    public int maxProfit(int[] prices) {
        int n = prices.length;
        int[][] f = new int[n][2];
        f[0][0] = -prices[0];
        for (int i = 1; i < n; ++i) {
            f[i][0] = Math.max(f[i - 1][0], f[i - 1][1] - prices[i]);
            f[i][1] = Math.max(f[i - 1][1], f[i - 1][0] + prices[i]);
        }
        return f[n - 1][1];
    }
}
```

* [sol2-C++]

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        int f[n][2];
        f[0][0] = -prices[0];
        f[0][1] = 0;
        for (int i = 1; i < n; ++i) {
            f[i][0] = max(f[i - 1][0], f[i - 1][1] - prices[i]);
            f[i][1] = max(f[i - 1][1], f[i - 1][0] + prices[i]);
        }
        return f[n - 1][1];
    }
};
```

* [sol2-Go]

```go
func maxProfit(prices []int) int {
	n := len(prices)
	f := make([][2]int, n)
	f[0][0] = -prices[0]
	for i := 1; i < n; i++ {
		f[i][0] = max(f[i-1][0], f[i-1][1]-prices[i])
		f[i][1] = max(f[i-1][1], f[i-1][0]+prices[i])
	}
	return f[n-1][1]
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}
```

æˆ‘ä»¬å¯ä»¥å‘ç°ï¼Œåœ¨æ–¹æ³•äºŒä¸­ï¼Œç¬¬ $i$ å¤©çš„çŠ¶æ€ï¼Œåªä¸ç¬¬ $i-1$ å¤©çš„çŠ¶æ€æœ‰å…³ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥åªç”¨ä¸¤ä¸ªå˜é‡æ¥ç»´æŠ¤ç¬¬ $i-1$ å¤©çš„çŠ¶æ€ï¼Œä»è€Œå°†ç©ºé—´å¤æ‚åº¦ä¼˜åŒ–åˆ° $O(1)$ã€‚

* [sol3-Python3]

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n = len(prices)
        f = [-prices[0], 0]
        for i in range(1, n):
            g = [0] * 2
            g[0] = max(f[0], f[1] - prices[i])
            g[1] = max(f[1], f[0] + prices[i])
            f = g
        return f[1]
```

* [sol3-Java]

```java
class Solution {
    public int maxProfit(int[] prices) {
        int n = prices.length;
        int[] f = new int[] {-prices[0], 0};
        for (int i = 1; i < n; ++i) {
            int[] g = new int[2];
            g[0] = Math.max(f[0], f[1] - prices[i]);
            g[1] = Math.max(f[1], f[0] + prices[i]);
            f = g;
        }
        return f[1];
    }
}
```

* [sol3-C++]

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        int f[2] = {-prices[0], 0};
        for (int i = 1; i < n; ++i) {
            int g[2];
            g[0] = max(f[0], f[1] - prices[i]);
            g[1] = max(f[1], f[0] + prices[i]);
            f[0] = g[0], f[1] = g[1];
        }
        return f[1];
    }
};
```

* [sol3-Go]

```go
func maxProfit(prices []int) int {
	n := len(prices)
	f := [2]int{-prices[0], 0}
	for i := 1; i < n; i++ {
		g := [2]int{}
		g[0] = max(f[0], f[1]-prices[i])
		g[1] = max(f[1], f[0]+prices[i])
		f = g
	}
	return f[1]
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}
```

---

æœ‰ä»»ä½•é—®é¢˜ï¼Œæ¬¢è¿è¯„è®ºåŒºäº¤æµï¼Œæ¬¢è¿è¯„è®ºåŒºæä¾›å…¶å®ƒè§£é¢˜æ€è·¯ï¼ˆä»£ç ï¼‰ï¼Œä¹Ÿå¯ä»¥ç‚¹ä¸ªèµæ”¯æŒä¸€ä¸‹ä½œè€…å“ˆğŸ˜„~
