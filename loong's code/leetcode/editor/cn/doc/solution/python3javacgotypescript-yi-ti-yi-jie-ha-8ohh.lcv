**æ–¹æ³•ä¸€ï¼šå“ˆå¸Œè¡¨**

æˆ‘ä»¬æ³¨æ„åˆ°ï¼Œå¯¹äºŽä½ç½® $i$ï¼Œè‹¥ $fronts[i]$ ä¸Ž $backs[i]$ å…ƒç´ ç›¸åŒï¼Œåˆ™ä¸€å®šä¸æ»¡è¶³æ¡ä»¶ã€‚

å› æ­¤ï¼Œæˆ‘ä»¬å…ˆæ‰¾å‡ºæ­£é¢ä¸ŽèƒŒé¢ç›¸åŒçš„å…ƒç´ ï¼Œè®°å½•åœ¨å“ˆå¸Œè¡¨ $s$ ä¸­ã€‚

æŽ¥ä¸‹æ¥ï¼ŒéåŽ†æ­£é¢ä¸ŽèƒŒé¢çš„å…ƒç´ ï¼Œè‹¥å…ƒç´  $x$ ä¸åœ¨å“ˆå¸Œè¡¨ $s$ ä¸­ï¼Œåˆ™æ›´æ–°ç­”æ¡ˆçš„æœ€å°å€¼ã€‚

æœ€åŽï¼Œè‹¥æ‰¾åˆ°ä¸€ä¸ªæ»¡è¶³æ¡ä»¶çš„å…ƒç´ ï¼Œè¿”å›žç­”æ¡ˆï¼Œå¦åˆ™è¿”å›ž $0$ã€‚

* [sol1-Python3]

```python
class Solution:
    def flipgame(self, fronts: List[int], backs: List[int]) -> int:
        s = {a for a, b in zip(fronts, backs) if a == b}
        return min((x for x in chain(fronts, backs) if x not in s), default=0)
```

* [sol1-Java]

```java
class Solution {
    public int flipgame(int[] fronts, int[] backs) {
        Set<Integer> s = new HashSet<>();
        int n = fronts.length;
        for (int i = 0; i < n; ++i) {
            if (fronts[i] == backs[i]) {
                s.add(fronts[i]);
            }
        }
        int ans = 9999;
        for (int v : fronts) {
            if (!s.contains(v)) {
                ans = Math.min(ans, v);
            }
        }
        for (int v : backs) {
            if (!s.contains(v)) {
                ans = Math.min(ans, v);
            }
        }
        return ans % 9999;
    }
}
```

* [sol1-C++]

```cpp
class Solution {
public:
    int flipgame(vector<int>& fronts, vector<int>& backs) {
        unordered_set<int> s;
        int n = fronts.size();
        for (int i = 0; i < n; ++i) {
            if (fronts[i] == backs[i]) {
                s.insert(fronts[i]);
            }
        }
        int ans = 9999;
        for (int& v : fronts) {
            if (!s.count(v)) {
                ans = min(ans, v);
            }
        }
        for (int& v : backs) {
            if (!s.count(v)) {
                ans = min(ans, v);
            }
        }
        return ans % 9999;
    }
};
```

* [sol1-Go]

```go
func flipgame(fronts []int, backs []int) int {
	s := map[int]struct{}{}
	for i, a := range fronts {
		if a == backs[i] {
			s[a] = struct{}{}
		}
	}
	ans := 9999
	for _, v := range fronts {
		if _, ok := s[v]; !ok {
			ans = min(ans, v)
		}
	}
	for _, v := range backs {
		if _, ok := s[v]; !ok {
			ans = min(ans, v)
		}
	}
	return ans % 9999
}

func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}
```

* [sol1-TypeScript]

```ts
function flipgame(fronts: number[], backs: number[]): number {
	const s: Set<number> = new Set();
	const n = fronts.length;
	for (let i = 0; i < n; ++i) {
		if (fronts[i] === backs[i]) {
			s.add(fronts[i]);
		}
	}
	let ans = 9999;
	for (const v of fronts) {
		if (!s.has(v)) {
			ans = Math.min(ans, v);
		}
	}
	for (const v of backs) {
		if (!s.has(v)) {
			ans = Math.min(ans, v);
		}
	}
	return ans % 9999;
};
```

æ—¶é—´å¤æ‚åº¦ $O(n)$ï¼Œç©ºé—´å¤æ‚åº¦ $O(n)$ã€‚å…¶ä¸­ $n$ æ˜¯æ•°ç»„çš„é•¿åº¦ã€‚

---

æœ‰ä»»ä½•é—®é¢˜ï¼Œæ¬¢è¿Žè¯„è®ºåŒºäº¤æµï¼Œæ¬¢è¿Žè¯„è®ºåŒºæä¾›å…¶å®ƒè§£é¢˜æ€è·¯ï¼ˆä»£ç ï¼‰ï¼Œä¹Ÿå¯ä»¥ç‚¹ä¸ªèµžæ”¯æŒä¸€ä¸‹ä½œè€…å“ˆðŸ˜„~
