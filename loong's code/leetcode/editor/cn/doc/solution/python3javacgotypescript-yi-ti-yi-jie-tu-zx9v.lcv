**æ–¹æ³•ä¸€ï¼šæ‹“æ‰‘æ’åº**

æˆ‘ä»¬å…ˆå°† $edges$ ä¸­çš„è¾¹è½¬æ¢æˆé‚»æ¥è¡¨ $g$ï¼Œå…¶ä¸­ $g[i]$ è¡¨ç¤ºèŠ‚ç‚¹ $i$ çš„æ‰€æœ‰é‚»æ¥èŠ‚ç‚¹ï¼Œç”¨é›†åˆè¡¨ç¤ºã€‚

æ¥ä¸‹æ¥æˆ‘ä»¬éå†æ‰€æœ‰èŠ‚ç‚¹ï¼Œæ‰¾åˆ° $coins[i]=0$ ä¸” $g[i]$ ä¸­åªæœ‰ä¸€ä¸ªèŠ‚ç‚¹çš„èŠ‚ç‚¹ï¼ˆä¹Ÿå³æ˜¯é‡‘å¸ä¸º $0$ çš„å¶å­èŠ‚ç‚¹ï¼‰ï¼Œå°†å…¶åŠ å…¥é˜Ÿåˆ— $q$ ä¸­ã€‚

ç„¶åæˆ‘ä»¬ä¸æ–­åœ°ä»é˜Ÿåˆ—ä¸­å–å‡ºèŠ‚ç‚¹ï¼Œå°†å…¶ä»é‚»æ¥è¡¨ä¸­åˆ é™¤ï¼Œç„¶ååˆ¤æ–­å…¶é‚»æ¥èŠ‚ç‚¹æ˜¯å¦æ»¡è¶³ $coins[j]=0$ ä¸” $g[j]$ ä¸­åªæœ‰ä¸€ä¸ªèŠ‚ç‚¹çš„æ¡ä»¶ï¼Œå¦‚æœæ»¡è¶³åˆ™å°†å…¶åŠ å…¥é˜Ÿåˆ— $q$ ä¸­ã€‚å¾ªç¯ï¼Œç›´è‡³é˜Ÿåˆ—ä¸ºç©ºã€‚

ç»è¿‡ä¸Šè¿°æ“ä½œåï¼Œæˆ‘ä»¬å¾—åˆ°äº†ä¸€æ£µæ–°çš„æ ‘ï¼Œä¸”æ ‘çš„å¶å­èŠ‚ç‚¹éƒ½æ˜¯é‡‘å¸ä¸º $1$ çš„èŠ‚ç‚¹ã€‚

ç„¶åï¼Œæˆ‘ä»¬å†åˆ é™¤å‰©ä¸‹çš„ä¸¤å±‚å¶å­èŠ‚ç‚¹ï¼Œæœ€ç»ˆå¾—åˆ°çš„æ˜¯ä¸€æ£µæ‰€æœ‰èŠ‚ç‚¹éƒ½éœ€è¦è¢«è®¿é—®çš„èŠ‚ç‚¹ï¼Œæˆ‘ä»¬åªéœ€è¦ç»Ÿè®¡å…¶è¾¹æ•°ï¼Œä¹˜ä¸Š $2$ï¼Œå³ä¸ºç­”æ¡ˆã€‚

* [sol1-Python3]

```python
class Solution:
    def collectTheCoins(self, coins: List[int], edges: List[List[int]]) -> int:
        g = defaultdict(set)
        for a, b in edges:
            g[a].add(b)
            g[b].add(a)
        n = len(coins)
        q = deque(i for i in range(n) if len(g[i]) == 1 and coins[i] == 0)
        while q:
            i = q.popleft()
            for j in g[i]:
                g[j].remove(i)
                if coins[j] == 0 and len(g[j]) == 1:
                    q.append(j)
            g[i].clear()
        for k in range(2):
            q = [i for i in range(n) if len(g[i]) == 1]
            for i in q:
                for j in g[i]:
                    g[j].remove(i)
                g[i].clear()
        return sum(len(g[a]) > 0 and len(g[b]) > 0 for a, b in edges) * 2
```

* [sol1-Java]

```java
class Solution {
    public int collectTheCoins(int[] coins, int[][] edges) {
        int n = coins.length;
        Set<Integer>[] g = new Set[n];
        Arrays.setAll(g, k -> new HashSet<>());
        for (var e : edges) {
            int a = e[0], b = e[1];
            g[a].add(b);
            g[b].add(a);
        }
        Deque<Integer> q = new ArrayDeque<>();
        for (int i = 0; i < n; ++i) {
            if (coins[i] == 0 && g[i].size() == 1) {
                q.offer(i);
            }
        }
        while (!q.isEmpty()) {
            int i = q.poll();
            for (int j : g[i]) {
                g[j].remove(i);
                if (coins[j] == 0 && g[j].size() == 1) {
                    q.offer(j);
                }
            }
            g[i].clear();
        }
        q.clear();
        for (int k = 0; k < 2; ++k) {
            for (int i = 0; i < n; ++i) {
                if (g[i].size() == 1) {
                    q.offer(i);
                }
            }
            for (int i : q) {
                for (int j : g[i]) {
                    g[j].remove(i);
                }
                g[i].clear();
            }
        }
        int ans = 0;
        for (var e : edges) {
            int a = e[0], b = e[1];
            if (g[a].size() > 0 && g[b].size() > 0) {
                ans += 2;
            }
        }
        return ans;
    }
}
```

* [sol1-C++]

```cpp
class Solution {
public:
    int collectTheCoins(vector<int>& coins, vector<vector<int>>& edges) {
        int n = coins.size();
        unordered_set<int> g[n];
        for (auto& e : edges) {
            int a = e[0], b = e[1];
            g[a].insert(b);
            g[b].insert(a);
        }
        queue<int> q;
        for (int i = 0; i < n; ++i) {
            if (coins[i] == 0 && g[i].size() == 1) {
                q.push(i);
            }
        }
        while (!q.empty()) {
            int i = q.front();
            q.pop();
            for (int j : g[i]) {
                g[j].erase(i);
                if (coins[j] == 0 && g[j].size() == 1) {
                    q.push(j);
                }
            }
            g[i].clear();
        }
        for (int k = 0; k < 2; ++k) {
            vector<int> q;
            for (int i = 0; i < n; ++i) {
                if (g[i].size() == 1) {
                    q.push_back(i);
                }
            }
            for (int i : q) {
                for (int j : g[i]) {
                    g[j].erase(i);
                }
                g[i].clear();
            }
        }
        int ans = 0;
        for (auto& e : edges) {
            int a = e[0], b = e[1];
            if (g[a].size() && g[b].size()) {
                ans += 2;
            }
        }
        return ans;
    }
};
```

* [sol1-Go]

```go
func collectTheCoins(coins []int, edges [][]int) int {
	n := len(coins)
	g := make([]map[int]bool, n)
	for i := range g {
		g[i] = map[int]bool{}
	}
	for _, e := range edges {
		a, b := e[0], e[1]
		g[a][b] = true
		g[b][a] = true
	}
	q := []int{}
	for i, c := range coins {
		if c == 0 && len(g[i]) == 1 {
			q = append(q, i)
		}
	}
	for len(q) > 0 {
		i := q[0]
		q = q[1:]
		for j := range g[i] {
			delete(g[j], i)
			if coins[j] == 0 && len(g[j]) == 1 {
				q = append(q, j)
			}
		}
		g[i] = map[int]bool{}
	}
	for k := 0; k < 2; k++ {
		q := []int{}
		for i := range coins {
			if len(g[i]) == 1 {
				q = append(q, i)
			}
		}
		for _, i := range q {
			for j := range g[i] {
				delete(g[j], i)
			}
			g[i] = map[int]bool{}
		}
	}
	ans := 0
	for _, e := range edges {
		a, b := e[0], e[1]
		if len(g[a]) > 0 && len(g[b]) > 0 {
			ans += 2
		}
	}
	return ans
}
```

* [sol1-TypeScript]

```ts
function collectTheCoins(coins: number[], edges: number[][]): number {
    const n = coins.length;
    const g: Set<number>[] = new Array(n).fill(0).map(() => new Set<number>());
    for (const [a, b] of edges) {
        g[a].add(b);
        g[b].add(a);
    }
    let q: number[] = [];
    for (let i = 0; i < n; ++i) {
        if (coins[i] === 0 && g[i].size === 1) {
            q.push(i);
        }
    }
    while (q.length) {
        const i = q.pop()!;
        for (const j of g[i]) {
            g[j].delete(i);
            if (coins[j] === 0 && g[j].size === 1) {
                q.push(j);
            }
        }
        g[i].clear();
    }
    q = [];
    for (let k = 0; k < 2; ++k) {
        for (let i = 0; i < n; ++i) {
            if (g[i].size === 1) {
                q.push(i);
            }
        }
        for (const i of q) {
            for (const j of g[i]) {
                g[j].delete(i);
            }
            g[i].clear();
        }
    }
    let ans = 0;
    for (const [a, b] of edges) {
        if (g[a].size > 0 && g[b].size > 0) {
            ans += 2;
        }
    }
    return ans;
}
```

æ—¶é—´å¤æ‚åº¦ $O(n)$ï¼Œç©ºé—´å¤æ‚åº¦ $O(n)$ã€‚å…¶ä¸­ $n$ ä¸ºèŠ‚ç‚¹æ•°ã€‚

---

æœ‰ä»»ä½•é—®é¢˜ï¼Œæ¬¢è¿è¯„è®ºåŒºäº¤æµï¼Œæ¬¢è¿è¯„è®ºåŒºæä¾›å…¶å®ƒè§£é¢˜æ€è·¯ï¼ˆä»£ç ï¼‰ï¼Œä¹Ÿå¯ä»¥ç‚¹ä¸ªèµæ”¯æŒä¸€ä¸‹ä½œè€…å“ˆğŸ˜„~
