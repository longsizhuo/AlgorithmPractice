Dijkstra è§£æ³•è¯·ç§»æ­¥[ä¸‰å¶çš„é¢˜è§£](https://leetcode-cn.com/problems/trapping-rain-water-ii/solution/gong-shui-san-xie-jing-dian-dijkstra-yun-13ik/)ğŸ¤©ğŸ¤©ğŸ¤©

## æ€è·¯

**ä¸ºä»€ä¹ˆå¯ä»¥ç”¨å¹¶æŸ¥é›†ï¼Ÿ**
é¢˜ç›®é—®çš„æ˜¯ï¼Œå„ä¸ªå•å…ƒèƒ½å®¹çº³æ°´çš„æœ€å¤§æ•°é‡ï¼Œè€ƒè™‘å…ˆå¯¹æ‰€æœ‰å•å…ƒæŒ‰é«˜åº¦å‡åºæ’åˆ—ï¼Œç„¶åæ¨¡æ‹Ÿæ¶¨æ°´è¿‡ç¨‹ï¼Œæ¯æ¬¡å°†æ°´ä½æ¶¨åˆ°æœªå¤„ç†å•å…ƒçš„æœ€å°é«˜åº¦ï¼Œå³æŒ‰å‡åºæ’åˆ—é¡ºåºå¤„ç†

æ¯æ¬¡å¤„ç†ä¸€ä¸ªå•å…ƒæ ¼æ—¶ï¼Œå¦‚æœå…¶ä¸Šä¸‹å·¦å³æ–¹å‘å­˜åœ¨å…¶å®ƒå·²å¤„ç†çš„å•å…ƒï¼Œå°†å®ƒä»¬å¹¶å…¥åŒä¸€ä¸ªé›†åˆä¸­ï¼Œå¦‚æœå¹¶å…¥é›†åˆåï¼Œè¯¥é›†åˆä¸è¾¹ç•Œè¿é€šï¼Œå¦‚ä¸‹å›¾ï¼š
![pwtu.jpg](https://pic.leetcode-cn.com/1635904888-pgoeTC-pwtu.jpg)

è¯´æ˜è“è‰²å•å…ƒé›†åˆæœ€å¤§ç››æ°´é«˜åº¦å³ä¸ºå½“å‰æ°´ä½é«˜åº¦ï¼ˆä¹Ÿå³æ©˜è‰²å•å…ƒçš„é«˜åº¦ï¼‰ï¼Œå°†è“è‰²å•å…ƒé›†åˆå¹¶å…¥ç»¿è‰²å•å…ƒé›†åˆï¼Œå¹¶å°†è“è‰²å•å…ƒé›†åˆçš„ç››æ°´é‡åŠ å…¥å…¥æœ€ç»ˆç»“æœ

å› ä¸ºæ˜¯æŒ‰ç…§é«˜åº¦ä»å°åˆ°å¤§çš„é¡ºåºå¤„ç†ï¼Œæ•…è“è‰²å•å…ƒé›†åˆå‘¨å›´çš„å…¶å®ƒå•å…ƒçš„é«˜åº¦å¿…ç„¶å¤§äºç­‰äºæ©˜è‰²å•å…ƒçš„é«˜åº¦

è®¾å½“å‰è“è‰²å•å…ƒé›†åˆçš„æ‰€æœ‰å•å…ƒçš„é«˜åº¦æ€»å’Œä¸º $Hs_{blue}$ï¼Œå•å…ƒä¸ªæ•°ä¸º $Cnt_{blue}$ï¼Œç››æ°´å®¹é‡ä¸º $Cap_{blue}$ï¼Œæ©˜è‰²å•å…ƒçš„é«˜åº¦ä¸º $H_{orange}$ï¼Œåˆ™è®¡ç®—å…¬å¼ä¸ºï¼š
$$
Cap_{blue} = Cnt_{blue} \times H_{orange} - Hs_{blue}
$$
å…¶ä¸­ $Hs_{blue}$ å’Œ $Cnt_{blue}$ å¯ä»¥åœ¨é›†åˆåˆå¹¶çš„è¿‡ç¨‹ä¸­è®¡ç®—

## å®ç°

> å°†0ä½œä¸ºçŸ©é˜µå¤–å•å…ƒçš„é›†åˆï¼Œ$row \times n + col + 1$ï¼Œä½œä¸ºå•å…ƒ $(row, col)$ çš„åˆå§‹é›†åˆï¼Œ$cnt[row \times n + col + 1] > 0$ æ—¶å³å¯è¯´æ˜è¯¥å•å…ƒå·²å¤„ç†
> å®ç°æ–¹å¼ä¸å”¯ä¸€ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨å…¶å®ƒæ–¹å¼

* 

```
def boundary(row: int, column: int, offsets=None):
    if offsets is None:
        offsets = [(-1, 0), (1, 0), (0, 1), (0, -1)]

    def around(r: int, c: int, valid=None):
        for dr, dc in offsets:
            nr, nc = r + dr, c + dc
            if 0 <= nr < row and 0 <= nc < column:
                if valid is None or valid(nr, nc):
                    yield nr, nc

    return around

class Solution:
    def trapRainWater(self, heights: List[List[int]]) -> int:
        m, n = len(heights), len(heights[0])
        arr = [(heights[i][j], i, j) for j in range(n) for i in range(m)]
        arr.sort(key=lambda it:it[0])

        f = list(range(m * n + 1))
        cnt = [0] * (m * n + 1)
        hs = [0] * (m * n + 1)
        ans = 0

        def find(i):
            if i != f[i]:
                f[i] = find(f[i])
            return f[i]

        def union(i, j, h):
            nonlocal ans
            fi, fj = find(i), find(j)
            if fi != fj:
                if fi > fj:
                    fi, fj = fj, fi
                f[fj] = fi
                cnt[fi] += cnt[fj]
                hs[fi] += hs[fj]
                if fi == 0:
                    ans += h * cnt[fj] - hs[fj]

        around = boundary(m, n)
        for h, i, j in arr:
            ij = i * n + j + 1
            cnt[ij], hs[ij] = 1, h
            for ni, nj in around(i, j):
                nij = ni * n + nj + 1
                if cnt[nij] > 0:
                    union(ij, nij, h)
            if i == 0 or j == 0 or i == m - 1 or j == n - 1:
                union(0, ij, h)

        return ans
```

