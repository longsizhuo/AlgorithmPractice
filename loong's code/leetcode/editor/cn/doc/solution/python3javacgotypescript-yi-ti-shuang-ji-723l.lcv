### æ–¹æ³•ä¸€ï¼šåŠ¨æ€è§„åˆ’

æˆ‘ä»¬è®°æ•°ç»„ $\text{nums}$ æ‰€æœ‰å…ƒç´ çš„å’Œä¸º $s$ï¼Œæ·»åŠ è´Ÿå·çš„å…ƒç´ ä¹‹å’Œä¸º $x$ï¼Œåˆ™æ·»åŠ æ­£å·çš„å…ƒç´ ä¹‹å’Œä¸º $s - x$ï¼Œåˆ™æœ‰ï¼š

$$
(s - x) - x = \text{target} \Rightarrow x = \frac{s - \text{target}}{2}
$$

ç”±äº $x \geq 0$ï¼Œä¸” $x$ ä¸ºæ•´æ•°ï¼Œæ‰€ä»¥ $s \geq \text{target}$ ä¸” $s - \text{target}$ ä¸ºå¶æ•°ã€‚å¦‚æœä¸æ»¡è¶³è¿™ä¸¤ä¸ªæ¡ä»¶ï¼Œåˆ™ç›´æ¥è¿”å› $0$ã€‚

æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬å¯ä»¥å°†é—®é¢˜è½¬åŒ–ä¸ºï¼šåœ¨æ•°ç»„ $\text{nums}$ ä¸­é€‰å–è‹¥å¹²å…ƒç´ ï¼Œä½¿å¾—è¿™äº›å…ƒç´ ä¹‹å’Œç­‰äº $\frac{s - \text{target}}{2}$ï¼Œé—®æœ‰å¤šå°‘ç§é€‰å–æ–¹æ³•ã€‚

æˆ‘ä»¬å¯ä»¥ä½¿ç”¨åŠ¨æ€è§„åˆ’æ¥è§£å†³è¿™ä¸ªé—®é¢˜ã€‚å®šä¹‰ $f[i][j]$ è¡¨ç¤ºåœ¨æ•°ç»„ $\text{nums}$ çš„å‰ $i$ ä¸ªå…ƒç´ ä¸­é€‰å–è‹¥å¹²å…ƒç´ ï¼Œä½¿å¾—è¿™äº›å…ƒç´ ä¹‹å’Œç­‰äº $j$ çš„é€‰å–æ–¹æ¡ˆæ•°ã€‚

å¯¹äº $\text{nums}[i - 1]$ï¼Œæˆ‘ä»¬æœ‰ä¸¤ç§é€‰æ‹©ï¼šé€‰å–æˆ–ä¸é€‰å–ã€‚å¦‚æœæˆ‘ä»¬ä¸é€‰å– $\text{nums}[i - 1]$ï¼Œåˆ™ $f[i][j] = f[i - 1][j]$ï¼›å¦‚æœæˆ‘ä»¬é€‰å– $\text{nums}[i - 1]$ï¼Œåˆ™ $f[i][j] = f[i - 1][j - \text{nums}[i - 1]]$ã€‚å› æ­¤ï¼ŒçŠ¶æ€è½¬ç§»æ–¹ç¨‹ä¸ºï¼š

$$
f[i][j] = f[i - 1][j] + f[i - 1][j - \text{nums}[i - 1]]
$$

å…¶ä¸­ï¼Œé€‰å–çš„å‰ææ˜¯ $j \geq \text{nums}[i - 1]$ã€‚

æœ€ç»ˆç­”æ¡ˆå³ä¸º $f[m][n]$ã€‚å…¶ä¸­ $m$ ä¸ºæ•°ç»„ $\text{nums}$ çš„é•¿åº¦ï¼Œè€Œ $n = \frac{s - \text{target}}{2}$ã€‚

* [sol1-Python3]

```python
class Solution:
    def findTargetSumWays(self, nums: List[int], target: int) -> int:
        s = sum(nums)
        if s < target or (s - target) % 2:
            return 0
        m, n = len(nums), (s - target) // 2
        f = [[0] * (n + 1) for _ in range(m + 1)]
        f[0][0] = 1
        for i, x in enumerate(nums, 1):
            for j in range(n + 1):
                f[i][j] = f[i - 1][j]
                if j >= x:
                    f[i][j] += f[i - 1][j - x]
        return f[m][n]
```

* [sol1-Java]

```java
class Solution {
    public int findTargetSumWays(int[] nums, int target) {
        int s = Arrays.stream(nums).sum();
        if (s < target || (s - target) % 2 != 0) {
            return 0;
        }
        int m = nums.length;
        int n = (s - target) / 2;
        int[][] f = new int[m + 1][n + 1];
        f[0][0] = 1;
        for (int i = 1; i <= m; ++i) {
            for (int j = 0; j <= n; ++j) {
                f[i][j] = f[i - 1][j];
                if (j >= nums[i - 1]) {
                    f[i][j] += f[i - 1][j - nums[i - 1]];
                }
            }
        }
        return f[m][n];
    }
}
```

* [sol1-C++]

```cpp
class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int target) {
        int s = accumulate(nums.begin(), nums.end(), 0);
        if (s < target || (s - target) % 2) {
            return 0;
        }
        int m = nums.size();
        int n = (s - target) / 2;
        int f[m + 1][n + 1];
        memset(f, 0, sizeof(f));
        f[0][0] = 1;
        for (int i = 1; i <= m; ++i) {
            for (int j = 0; j <= n; ++j) {
                f[i][j] = f[i - 1][j];
                if (j >= nums[i - 1]) {
                    f[i][j] += f[i - 1][j - nums[i - 1]];
                }
            }
        }
        return f[m][n];
    }
};
```

* [sol1-Go]

```go
func findTargetSumWays(nums []int, target int) int {
	s := 0
	for _, x := range nums {
		s += x
	}
	if s < target || (s-target)%2 != 0 {
		return 0
	}
	m, n := len(nums), (s-target)/2
	f := make([][]int, m+1)
	for i := range f {
		f[i] = make([]int, n+1)
	}
	f[0][0] = 1
	for i := 1; i <= m; i++ {
		for j := 0; j <= n; j++ {
			f[i][j] = f[i-1][j]
			if j >= nums[i-1] {
				f[i][j] += f[i-1][j-nums[i-1]]
			}
		}
	}
	return f[m][n]
}
```

* [sol1-TypeScript]

```ts
function findTargetSumWays(nums: number[], target: number): number {
    const s = nums.reduce((a, b) => a + b, 0);
    if (s < target || (s - target) % 2) {
        return 0;
    }
    const [m, n] = [nums.length, ((s - target) / 2) | 0];
    const f: number[][] = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0));
    f[0][0] = 1;
    for (let i = 1; i <= m; i++) {
        for (let j = 0; j <= n; j++) {
            f[i][j] = f[i - 1][j];
            if (j >= nums[i - 1]) {
                f[i][j] += f[i - 1][j - nums[i - 1]];
            }
        }
    }
    return f[m][n];
}
```

* [sol1-Rust]

```rust
impl Solution {
    pub fn find_target_sum_ways(nums: Vec<i32>, target: i32) -> i32 {
        let s: i32 = nums.iter().sum();
        if s < target || (s - target) % 2 != 0 {
            return 0;
        }
        let m = nums.len();
        let n = ((s - target) / 2) as usize;
        let mut f = vec![vec![0; n + 1]; m + 1];
        f[0][0] = 1;
        for i in 1..=m {
            for j in 0..=n {
                f[i][j] = f[i - 1][j];
                if j as i32 >= nums[i - 1] {
                    f[i][j] += f[i - 1][j - nums[i - 1] as usize];
                }
            }
        }
        f[m][n]
    }
}
```

* [sol1-JavaScript]

```js
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var findTargetSumWays = function (nums, target) {
    const s = nums.reduce((a, b) => a + b, 0);
    if (s < target || (s - target) % 2) {
        return 0;
    }
    const [m, n] = [nums.length, ((s - target) / 2) | 0];
    const f = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0));
    f[0][0] = 1;
    for (let i = 1; i <= m; i++) {
        for (let j = 0; j <= n; j++) {
            f[i][j] = f[i - 1][j];
            if (j >= nums[i - 1]) {
                f[i][j] += f[i - 1][j - nums[i - 1]];
            }
        }
    }
    return f[m][n];
};
```

æ—¶é—´å¤æ‚åº¦ $O(m \times n)$ï¼Œç©ºé—´å¤æ‚åº¦ $O(m \times n)$ã€‚

----

### æ–¹æ³•äºŒï¼šåŠ¨æ€è§„åˆ’ï¼ˆç©ºé—´ä¼˜åŒ–ï¼‰

æˆ‘ä»¬å¯ä»¥å‘ç°ï¼Œæ–¹æ³•ä¸€ä¸­çš„çŠ¶æ€è½¬ç§»æ–¹ç¨‹ä¸­ï¼Œ$f[i][j]$ çš„å€¼åªå’Œ $f[i - 1][j]$ ä»¥åŠ $f[i - 1][j - \text{nums}[i - 1]]$ æœ‰å…³ï¼Œå› æ­¤æˆ‘ä»¬å»æ‰ç¬¬ä¸€ç»´ç©ºé—´ï¼Œåªä½¿ç”¨ä¸€ç»´æ•°ç»„å³å¯ã€‚

* [sol2-Python3]

```python
class Solution:
    def findTargetSumWays(self, nums: List[int], target: int) -> int:
        s = sum(nums)
        if s < target or (s - target) % 2:
            return 0
        n = (s - target) // 2
        f = [0] * (n + 1)
        f[0] = 1
        for x in nums:
            for j in range(n, x - 1, -1):
                f[j] += f[j - x]
        return f[n]
```

* [sol2-Java]

```java
class Solution {
    public int findTargetSumWays(int[] nums, int target) {
        int s = Arrays.stream(nums).sum();
        if (s < target || (s - target) % 2 != 0) {
            return 0;
        }
        int n = (s - target) / 2;
        int[] f = new int[n + 1];
        f[0] = 1;
        for (int num : nums) {
            for (int j = n; j >= num; --j) {
                f[j] += f[j - num];
            }
        }
        return f[n];
    }
}
```

* [sol2-C++]

```cpp
class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int target) {
        int s = accumulate(nums.begin(), nums.end(), 0);
        if (s < target || (s - target) % 2) {
            return 0;
        }
        int n = (s - target) / 2;
        int f[n + 1];
        memset(f, 0, sizeof(f));
        f[0] = 1;
        for (int x : nums) {
            for (int j = n; j >= x; --j) {
                f[j] += f[j - x];
            }
        }
        return f[n];
    }
};
```

* [sol2-Go]

```go
func findTargetSumWays(nums []int, target int) int {
	s := 0
	for _, x := range nums {
		s += x
	}
	if s < target || (s-target)%2 != 0 {
		return 0
	}
	n := (s - target) / 2
	f := make([]int, n+1)
	f[0] = 1
	for _, x := range nums {
		for j := n; j >= x; j-- {
			f[j] += f[j-x]
		}
	}
	return f[n]
}
```

* [sol2-TypeScript]

```ts
function findTargetSumWays(nums: number[], target: number): number {
    const s = nums.reduce((a, b) => a + b, 0);
    if (s < target || (s - target) % 2) {
        return 0;
    }
    const n = ((s - target) / 2) | 0;
    const f = Array(n + 1).fill(0);
    f[0] = 1;
    for (const x of nums) {
        for (let j = n; j >= x; j--) {
            f[j] += f[j - x];
        }
    }
    return f[n];
}
```

* [sol2-Rust]

```rust
impl Solution {
    pub fn find_target_sum_ways(nums: Vec<i32>, target: i32) -> i32 {
        let s: i32 = nums.iter().sum();
        if s < target || (s - target) % 2 != 0 {
            return 0;
        }
        let n = ((s - target) / 2) as usize;
        let mut f = vec![0; n + 1];
        f[0] = 1;
        for x in nums {
            for j in (x as usize..=n).rev() {
                f[j] += f[j - x as usize];
            }
        }
        f[n]
    }
}
```

* [sol2-JavaScript]

```js
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var findTargetSumWays = function (nums, target) {
    const s = nums.reduce((a, b) => a + b, 0);
    if (s < target || (s - target) % 2) {
        return 0;
    }
    const n = (s - target) / 2;
    const f = Array(n + 1).fill(0);
    f[0] = 1;
    for (const x of nums) {
        for (let j = n; j >= x; j--) {
            f[j] += f[j - x];
        }
    }
    return f[n];
};
```

æ—¶é—´å¤æ‚åº¦ $O(m \times n)$ï¼Œç©ºé—´å¤æ‚åº¦ $O(n)$ã€‚

---

æœ‰ä»»ä½•é—®é¢˜ï¼Œæ¬¢è¿è¯„è®ºåŒºäº¤æµï¼Œæ¬¢è¿è¯„è®ºåŒºæä¾›å…¶å®ƒè§£é¢˜æ€è·¯ï¼ˆä»£ç ï¼‰ï¼Œä¹Ÿå¯ä»¥ç‚¹ä¸ªèµæ”¯æŒä¸€ä¸‹ä½œè€…å“ˆğŸ˜„~
