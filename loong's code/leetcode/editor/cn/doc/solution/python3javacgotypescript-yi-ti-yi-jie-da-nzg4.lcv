**æ–¹æ³•ä¸€ï¼šå•è°ƒæ ˆ**

é¢˜ç›®è¦æ±‚çš„æ˜¯æ¯ä¸ªå­æ•°ç»„çš„æœ€å°å€¼ä¹‹å’Œï¼Œå®é™…ä¸Šç›¸å½“äºï¼Œå¯¹äºæ¯ä¸ªå…ƒç´  $arr[i]$ï¼Œæ±‚ä»¥ $arr[i]$ ä¸ºæœ€å°å€¼çš„å­æ•°ç»„çš„ä¸ªæ•°ï¼Œç„¶åä¹˜ä»¥ $arr[i]$ï¼Œæœ€åæ±‚å’Œã€‚

å› æ­¤ï¼Œé¢˜ç›®çš„é‡ç‚¹è½¬æ¢ä¸ºï¼šæ±‚ä»¥ $arr[i]$ ä¸ºæœ€å°å€¼çš„å­æ•°ç»„çš„ä¸ªæ•°ã€‚å¯¹äº $arr[i]$ï¼Œæˆ‘ä»¬æ‰¾å‡ºå…¶å·¦è¾¹ç¬¬ä¸€ä¸ªå°äº $arr[i]$ çš„ä½ç½® $left[i]$ï¼Œå³ä¾§ç¬¬ä¸€ä¸ªå°äºç­‰äº $arr[i]$ çš„ä½ç½® $right[i]$ï¼Œåˆ™ä»¥ $arr[i]$ ä¸ºæœ€å°å€¼çš„å­æ•°ç»„çš„ä¸ªæ•°ä¸º $(i - left[i]) \times (right[i] - i)$ã€‚

æ³¨æ„ï¼Œè¿™é‡Œä¸ºä»€ä¹ˆè¦æ±‚å³ä¾§ç¬¬ä¸€ä¸ªå°äºç­‰äº $arr[i]$ çš„ä½ç½® $right[i]$ï¼Œè€Œä¸æ˜¯å°äº $arr[i]$ çš„ä½ç½®å‘¢ï¼Ÿè¿™æ˜¯å› ä¸ºï¼Œå¦‚æœæ˜¯å³ä¾§ç¬¬ä¸€ä¸ªå°äº $arr[i]$ çš„ä½ç½® $right[i]$ï¼Œåˆ™ä¼šå¯¼è‡´é‡å¤è®¡ç®—ã€‚

æˆ‘ä»¬å¯ä»¥ä¸¾ä¸ªä¾‹å­æ¥è¯´æ˜ï¼Œå¯¹äºä»¥ä¸‹æ•°ç»„ï¼š

ä¸‹æ ‡ä¸º $3$ çš„å…ƒç´ å¤§å°ä¸º $2$ï¼Œå·¦ä¾§ç¬¬ä¸€ä¸ªå°äº $2$ çš„å…ƒç´ ä¸‹æ ‡ä¸º $0$ï¼Œå¦‚æœæˆ‘ä»¬æ±‚å³ä¾§ç¬¬ä¸€ä¸ªå°äº $2$ çš„å…ƒç´ ä¸‹æ ‡ï¼Œå¯ä»¥å¾—åˆ°ä¸‹æ ‡ä¸º $7$ã€‚ä¹Ÿå³æ˜¯è¯´ï¼Œå­æ•°ç»„åŒºé—´ä¸º $(0, 7)$ã€‚æ³¨æ„ï¼Œè¿™é‡Œæ˜¯å¼€åŒºé—´ã€‚

* 

```
0 4 3 2 5 3 2 1
*     ^       *
```

æŒ‰ç…§åŒæ ·çš„æ–¹æ³•ï¼Œæˆ‘ä»¬å¯ä»¥æ±‚å‡ºä¸‹æ ‡ä¸º $6$ çš„å…ƒç´ çš„å­æ•°ç»„åŒºé—´ï¼Œå¯ä»¥å‘ç°ï¼Œå…¶å­æ•°ç»„åŒºé—´ä¹Ÿä¸º $(0, 7)$ï¼Œä¹Ÿå³æ˜¯è¯´ï¼Œä¸‹æ ‡ä¸º $3$ å’Œä¸‹æ ‡ä¸º $6$ çš„å…ƒç´ çš„å­æ•°ç»„åŒºé—´æ˜¯é‡å¤çš„ã€‚è¿™æ ·å°±é€ æˆäº†é‡å¤è®¡ç®—ã€‚

* 

```
0 4 3 2 5 3 2 1
*           ^ *
```

å¦‚æœæˆ‘ä»¬æ±‚çš„æ˜¯å³ä¾§ç¬¬ä¸€ä¸ªå°äºç­‰äºå…¶å€¼çš„ä¸‹æ ‡ï¼Œå°±ä¸ä¼šæœ‰é‡å¤é—®é¢˜ï¼Œå› ä¸ºä¸‹æ ‡ä¸º $3$ çš„å­æ•°ç»„åŒºé—´å˜ä¸º $(0, 6)$ï¼Œä¸‹æ ‡ä¸º $6$ çš„å­æ•°ç»„åŒºé—´ä¸º $(0, 7)$ï¼Œä¸¤è€…ä¸é‡å¤ã€‚

å›åˆ°è¿™é“é¢˜ä¸Šï¼Œæˆ‘ä»¬åªéœ€è¦éå†æ•°ç»„ï¼Œå¯¹äºæ¯ä¸ªå…ƒç´  $arr[i]$ï¼Œåˆ©ç”¨å•è°ƒæ ˆæ±‚å‡ºå…¶å·¦ä¾§ç¬¬ä¸€ä¸ªå°äº $arr[i]$ çš„ä½ç½® $left[i]$ï¼Œå³ä¾§ç¬¬ä¸€ä¸ªå°äºç­‰äº $arr[i]$ çš„ä½ç½® $right[i]$ï¼Œåˆ™ä»¥ $arr[i]$ ä¸ºæœ€å°å€¼çš„å­æ•°ç»„çš„ä¸ªæ•°ä¸º $(i - left[i]) \times (right[i] - i)$ï¼Œç„¶åä¹˜ä»¥ $arr[i]$ï¼Œæœ€åæ±‚å’Œå³å¯ã€‚

æ³¨æ„æ•°æ®çš„æº¢å‡ºä»¥åŠå–æ¨¡æ“ä½œã€‚

* [sol1-Python3]

```python
class Solution:
    def sumSubarrayMins(self, arr: List[int]) -> int:
        n = len(arr)
        left = [-1] * n
        right = [n] * n
        stk = []
        for i, v in enumerate(arr):
            while stk and arr[stk[-1]] >= v:
                stk.pop()
            if stk:
                left[i] = stk[-1]
            stk.append(i)

        stk = []
        for i in range(n - 1, -1, -1):
            while stk and arr[stk[-1]] > arr[i]:
                stk.pop()
            if stk:
                right[i] = stk[-1]
            stk.append(i)
        mod = 10**9 + 7
        return sum((i - left[i]) * (right[i] - i) * v for i, v in enumerate(arr)) % mod
```

* [sol1-Java]

```java
class Solution {
    public int sumSubarrayMins(int[] arr) {
        int n = arr.length;
        int[] left = new int[n];
        int[] right = new int[n];
        Arrays.fill(left, -1);
        Arrays.fill(right, n);
        Deque<Integer> stk = new ArrayDeque<>();
        for (int i = 0; i < n; ++i) {
            while (!stk.isEmpty() && arr[stk.peek()] >= arr[i]) {
                stk.pop();
            }
            if (!stk.isEmpty()) {
                left[i] = stk.peek();
            }
            stk.push(i);
        }
        stk.clear();
        for (int i = n - 1; i >= 0; --i) {
            while (!stk.isEmpty() && arr[stk.peek()] > arr[i]) {
                stk.pop();
            }
            if (!stk.isEmpty()) {
                right[i] = stk.peek();
            }
            stk.push(i);
        }
        final int mod = (int) 1e9 + 7;
        long ans = 0;
        for (int i = 0; i < n; ++i) {
            ans += (long) (i - left[i]) * (right[i] - i) % mod * arr[i] % mod;
            ans %= mod;
        }
        return (int) ans;
    }
}
```

* [sol1-C++]

```cpp
class Solution {
public:
    int sumSubarrayMins(vector<int>& arr) {
        int n = arr.size();
        vector<int> left(n, -1);
        vector<int> right(n, n);
        stack<int> stk;
        for (int i = 0; i < n; ++i) {
            while (!stk.empty() && arr[stk.top()] >= arr[i]) {
                stk.pop();
            }
            if (!stk.empty()) {
                left[i] = stk.top();
            }
            stk.push(i);
        }
        stk = stack<int>();
        for (int i = n - 1; i >= 0; --i) {
            while (!stk.empty() && arr[stk.top()] > arr[i]) {
                stk.pop();
            }
            if (!stk.empty()) {
                right[i] = stk.top();
            }
            stk.push(i);
        }
        long long ans = 0;
        const int mod = 1e9 + 7;
        for (int i = 0; i < n; ++i) {
            ans += 1LL * (i - left[i]) * (right[i] - i) * arr[i] % mod;
            ans %= mod;
        }
        return ans;
    }
};
```

* [sol1-Go]

```go
func sumSubarrayMins(arr []int) (ans int) {
	n := len(arr)
	left := make([]int, n)
	right := make([]int, n)
	for i := range left {
		left[i] = -1
		right[i] = n
	}
	stk := []int{}
	for i, v := range arr {
		for len(stk) > 0 && arr[stk[len(stk)-1]] >= v {
			stk = stk[:len(stk)-1]
		}
		if len(stk) > 0 {
			left[i] = stk[len(stk)-1]
		}
		stk = append(stk, i)
	}
	stk = []int{}
	for i := n - 1; i >= 0; i-- {
		for len(stk) > 0 && arr[stk[len(stk)-1]] > arr[i] {
			stk = stk[:len(stk)-1]
		}
		if len(stk) > 0 {
			right[i] = stk[len(stk)-1]
		}
		stk = append(stk, i)
	}
	const mod int = 1e9 + 7
	for i, v := range arr {
		ans += (i - left[i]) * (right[i] - i) * v % mod
		ans %= mod
	}
	return
}
```

* [sol1-TypeScript]

```ts
function sumSubarrayMins(arr: number[]): number {
    const n: number = arr.length;
    const left: number[] = Array(n).fill(-1);
    const right: number[] = Array(n).fill(n);
    const stk: number[] = [];
    for (let i = 0; i < n; ++i) {
        while (stk.length > 0 && arr[stk.at(-1)] >= arr[i]) {
            stk.pop();
        }
        if (stk.length > 0) {
            left[i] = stk.at(-1);
        }
        stk.push(i);
    }

    stk.length = 0;
    for (let i = n - 1; ~i; --i) {
        while (stk.length > 0 && arr[stk.at(-1)] > arr[i]) {
            stk.pop();
        }
        if (stk.length > 0) {
            right[i] = stk.at(-1);
        }
        stk.push(i);
    }

    const mod: number = 1e9 + 7;
    let ans: number = 0;
    for (let i = 0; i < n; ++i) {
        ans += ((((i - left[i]) * (right[i] - i)) % mod) * arr[i]) % mod;
        ans %= mod;
    }
    return ans;
}
```

* [sol1-Rust]

```rust
use std::collections::VecDeque;

impl Solution {
    pub fn sum_subarray_mins(arr: Vec<i32>) -> i32 {
        let n = arr.len();
        let mut left = vec![-1; n];
        let mut right = vec![n as i32; n];
        let mut stk: VecDeque<usize> = VecDeque::new();

        for i in 0..n {
            while !stk.is_empty() && arr[*stk.back().unwrap()] >= arr[i] {
                stk.pop_back();
            }
            if let Some(&top) = stk.back() {
                left[i] = top as i32;
            }
            stk.push_back(i);
        }

        stk.clear();
        for i in (0..n).rev() {
            while !stk.is_empty() && arr[*stk.back().unwrap()] > arr[i] {
                stk.pop_back();
            }
            if let Some(&top) = stk.back() {
                right[i] = top as i32;
            }
            stk.push_back(i);
        }

        let MOD = 1_000_000_007;
        let mut ans: i64 = 0;
        for i in 0..n {
            ans +=
                ((((right[i] - (i as i32)) * ((i as i32) - left[i])) as i64) * (arr[i] as i64)) %
                MOD;
            ans %= MOD;
        }
        ans as i32
    }
}
```

æ—¶é—´å¤æ‚åº¦ $O(n)$ï¼Œç©ºé—´å¤æ‚åº¦ $O(n)$ã€‚å…¶ä¸­ $n$ ä¸ºæ•°ç»„ $arr$ çš„é•¿åº¦ã€‚

---

æœ‰ä»»ä½•é—®é¢˜ï¼Œæ¬¢è¿è¯„è®ºåŒºäº¤æµï¼Œæ¬¢è¿è¯„è®ºåŒºæä¾›å…¶å®ƒè§£é¢˜æ€è·¯ï¼ˆä»£ç ï¼‰ï¼Œä¹Ÿå¯ä»¥ç‚¹ä¸ªèµæ”¯æŒä¸€ä¸‹ä½œè€…å“ˆğŸ˜„~
