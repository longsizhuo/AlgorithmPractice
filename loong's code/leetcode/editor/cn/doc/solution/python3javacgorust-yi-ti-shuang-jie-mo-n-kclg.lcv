**æ–¹æ³•ä¸€ï¼šæ¨¡æ‹Ÿ**

æˆ‘ä»¬å¯ä»¥æ¨¡æ‹Ÿæ•å¤´ä¼ é€’çš„è¿‡ç¨‹ï¼Œæ¯æ¬¡ä¼ é€’æ•å¤´æ—¶ï¼Œå¦‚æœæ•å¤´åˆ°è¾¾é˜Ÿé¦–æˆ–é˜Ÿå°¾ï¼Œä¼ é€’æ–¹å‘å°±ä¼šæ”¹å˜ï¼Œé˜Ÿä¼ä¼šç»§ç»­æ²¿ç›¸åæ–¹å‘ä¼ é€’æ•å¤´ã€‚

* [sol1-Python3]

```python
class Solution:
    def passThePillow(self, n: int, time: int) -> int:
        ans = k = 1
        for _ in range(time):
            ans += k
            if ans == 1 or ans == n:
                k *= -1
        return ans
```

* [sol1-Java]

```java
class Solution {
    public int passThePillow(int n, int time) {
        int ans = 1, k = 1;
        while (time-- > 0) {
            ans += k;
            if (ans == 1 || ans == n) {
                k *= -1;
            }
        }
        return ans;
    }
}
```

* [sol1-C++]

```cpp
class Solution {
public:
    int passThePillow(int n, int time) {
        int ans = 1, k = 1;
        while (time--) {
            ans += k;
            if (ans == 1 || ans == n) {
                k *= -1;
            }
        }
        return ans;
    }
};
```

* [sol1-Go]

```go
func passThePillow(n int, time int) int {
	ans, k := 1, 1
	for ; time > 0; time-- {
		ans += k
		if ans == 1 || ans == n {
			k *= -1
		}
	}
	return ans
}
```

* [sol1-Rust]

```rust
impl Solution {
    pub fn pass_the_pillow(n: i32, time: i32) -> i32 {
        let mut ans = 1;
        let mut k = 1;

        for i in 1..=time {
            ans += k;

            if ans == 1 || ans == n {
                k *= -1;
            }
        }

        ans
    }
}
```

* [sol1-TypeScript]

```ts
function passThePillow(n: number, time: number): number {
    let ans = 1,
        k = 1;
    while (time-- > 0) {
        ans += k;
        if (ans === 1 || ans === n) {
            k *= -1;
        }
    }
    return ans;
}
```

æ—¶é—´å¤æ‚åº¦ $O(time)$ï¼Œç©ºé—´å¤æ‚åº¦ $O(1)$ã€‚å…¶ä¸­ $time$ ä¸ºç»™å®šçš„æ—¶é—´ã€‚

-----

**æ–¹æ³•äºŒï¼šæ•°å­¦**

æˆ‘ä»¬æ³¨æ„åˆ°ï¼Œæ¯ä¸€è½®æœ‰ $n - 1$ æ¬¡ä¼ é€’ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥å°† $time$ é™¤ä»¥ $n - 1$ å¾—åˆ°æ•å¤´ä¼ é€’çš„è½®æ•° $k$ï¼Œç„¶åå†å°† $time$ å¯¹ $n - 1$ å–ä½™å¾—åˆ°æ•å¤´åœ¨å½“å‰è½®çš„å‰©ä½™ä¼ é€’æ¬¡æ•° $mod$ã€‚

æ¥ä¸‹æ¥æˆ‘ä»¬åˆ¤æ–­å½“å‰çš„è½®æ•° $k$ï¼š

- å¦‚æœ $k$ ä¸ºå¥‡æ•°ï¼Œé‚£ä¹ˆæ•å¤´å½“å‰çš„ä¼ é€’æ–¹å‘æ˜¯ä»é˜Ÿå°¾åˆ°é˜Ÿé¦–ï¼Œå› æ­¤æ•å¤´ä¼šä¼ é€’åˆ°ç¼–å·ä¸º $n - mod$ çš„äººæ‰‹ä¸­ï¼›
- å¦‚æœ $k$ ä¸ºå¶æ•°ï¼Œé‚£ä¹ˆæ•å¤´å½“å‰çš„ä¼ é€’æ–¹å‘æ˜¯ä»é˜Ÿé¦–åˆ°é˜Ÿå°¾ï¼Œå› æ­¤æ•å¤´ä¼šä¼ é€’åˆ°ç¼–å·ä¸º $mod + 1$ çš„äººæ‰‹ä¸­ã€‚

* [sol2-Python3]

```python
class Solution:
    def passThePillow(self, n: int, time: int) -> int:
        k, mod = divmod(time, n - 1)
        return n - mod if k & 1 else mod + 1
```

* [sol2-Java]

```java
class Solution {
    public int passThePillow(int n, int time) {
        int k = time / (n - 1);
        int mod = time % (n - 1);
        return (k & 1) == 1 ? n - mod : mod + 1;
    }
}
```

* [sol2-C++]

```cpp
class Solution {
public:
    int passThePillow(int n, int time) {
        int k = time / (n - 1);
        int mod = time % (n - 1);
        return k & 1 ? n - mod : mod + 1;
    }
};
```

* [sol2-Go]

```go
func passThePillow(n int, time int) int {
	k, mod := time/(n-1), time%(n-1)
	if k&1 == 1 {
		return n - mod
	}
	return mod + 1
}
```

* [sol2-Rust]

```rust
impl Solution {
    pub fn pass_the_pillow(n: i32, time: i32) -> i32 {
        let mut k = time / (n - 1);
        let mut _mod = time % (n - 1);

        if k & 1 == 1 {
            return n - _mod
        }

        _mod + 1
    }
}
```

* [sol2-TypeScript]

```ts
function passThePillow(n: number, time: number): number {
    const k = time / (n - 1);
    const mod = time % (n - 1);
    return (k & 1) == 1 ? n - mod : mod + 1;
}
```

æ—¶é—´å¤æ‚åº¦ $O(1)$ï¼Œç©ºé—´å¤æ‚åº¦ $O(1)$ã€‚

---

æœ‰ä»»ä½•é—®é¢˜ï¼Œæ¬¢è¿è¯„è®ºåŒºäº¤æµï¼Œæ¬¢è¿è¯„è®ºåŒºæä¾›å…¶å®ƒè§£é¢˜æ€è·¯ï¼ˆä»£ç ï¼‰ï¼Œä¹Ÿå¯ä»¥ç‚¹ä¸ªèµæ”¯æŒä¸€ä¸‹ä½œè€…å“ˆğŸ˜„~
